// How to use:// // In Flash//// Make a MovieClip with a separate layer for each body part// Each body part has to be a Graphic with one or more frames.// Make an empty layer, used only for frame labels, which designate the beginning of a sequence:// MovieClip//  ^ Empty Layer - [label frames]//  ^ Layer 1 - Graphic animated using motion object and static frames//  ^ Layer 2 - Graphic animated using motion object and static frames//// To export, either go to the top level of the document and select one or more movie clips,// or go into the timeline of a movie clip you wish to export and// run this script.//// You should see the JSON file printed out on output console, and written to disk.// PNGs for each frame of each symbol will also be written out.// The JSON file should be included in the app's bundle.// The PNGs have to be converted into a sprite sheet + plist, and also included in app's bundle. I use http://www.codeandweb.com/texturepacker/// See HelloWorldLayer.m for loading textures and playing animation.//// SUPPORTED:// Motion, scale, rotate, skew animation (MotionObject)// Tint, Advanced Tint, Alpha, Brightness animation// One or more sequences per MovieClip, using frame labels//// NOTES:// A layer has to be either completely empty (like the frame labels layer), or have the same symbol in all the frames.// All non-empty layers have to have the same length.// I recommend using meaningful names for layers and symbols - makes it easier to debug.// Animated color transformations are tweened linearly, disregarding easing// Each layer of the exported movie clip represents a single cocos2d sprite, to be animated.// Bones are not supported.// Frames can also have comments, which can be used programmatically as event triggers with FxAnimatedSprite.onFrameComment.// Flash file FPS controls global animation speed// When an animation is played by FxAnimatedSprite, it will smoothly tween in between frames, and snap to static frames// It's possible to hide a symbol by having blank frames, but first frame of timeline can not be blank, or layer won't be exported.// Hidden or guide layers are not exported.// All symbols inside the MovieClip being exported must be Graphic// Graphic's current frame is exported with the animation, respecting loop mode (single frame/loop/play once).//// DISCLAIMER:// Only tested with Flash CS6, on Mac only.// Use at own risk. This should leave your Flash file unmodified, but I do recommend backups.////// xjsfl.init(this); // for debugging http://www.xjsfl.comfl.outputPanel.clear();// uncomment below to pick folder each time// note that pickFolder() is only tested on a Mac. You may need to modify it for it to work on Winvar exportPNG = true, path = pickFolder();// OR uncomment / edit line below to use same path every time//var path = "file:///Users/nagual20/Dropbox/fx/FxAnimation/FxAnimation/Resources/", exportPNG = false;//var path = "file:///Users/nagual20/Dropbox/fx/FxAnimation/FxAnimation/Resources/", exportPNG = true;//xjsfl.debug.func(exportSelectedItems, [path, exportPNG]); // for debugging http://www.xjsfl.comif(path && path.length) exportSelectedItems(path, exportPNG);function exportSelectedItems(path, exportSymbols){	var doc = fl.getDocumentDOM();	var sel = doc.selection;	var tl = doc.getTimeline();		// editing in-place already	if(tl.libraryItem){		fl.trace("Exporting symbol in-place");		doc.selectNone();		exportAnimation(path, exportSymbols);		return;	} 		// nothing selected	if(sel.length == 0 ){		fl.trace("Nothing to export.\nSelect one or more symbols on stage, or edit-in-place a symbol and select nothing.");		return;	}		// export selection	fl.trace("Exporting selected "+sel.length+" symbol(s)");	for(var si = 0; si < sel.length; si++){		var item = sel[si];		doc.selectNone();		doc.selection = [ item ];		doc.enterEditMode('inPlace');		exportAnimation(path, exportSymbols);		doc.exitEditMode();	}		doc.selectNone();	doc.selection = sel;}function exportAnimation(path, exportSymbols){	// prepare	var doc = fl.getDocumentDOM();	var lib = doc.library;	var tl = doc.getTimeline();	var frameLabels = [ ];	var frameComments = [ ];	var layerSymbols = [ ];	var layerAnims = [ ];			var usedSymbols = { };	var identityCtx = { rp: 100, gp: 100, bp: 100, ap:100, ro: 0, go: 0, bo: 0, ao:0};		fl.trace("Exporting " + tl.libraryItem.name);		// for each layer	for(var li = 0; li < tl.layerCount; li++){		var layer = tl.layers[li];		if(!layer.visible || !(layer.layerType == 'normal' || layer.layerType == 'guided')) continue;		tl.currentLayer = layer;				// save which symbol occupies this layer		var emptyLayer = (layer.frames[0].elements.length == 0);		var layerLibItem = null;		if(!emptyLayer){			layerLibItem = layer.frames[0].elements[0].libraryItem;			usedSymbols[layerLibItem.name.split('/').pop()] = layerLibItem;			layerSymbols.push('{"layer":"' + layer.name + '", "symbol":"' + layerLibItem.name.split('/').pop() + '"}');		}						var currentAnim = [ ];		var currentMotionTween = 0;		var currentCtx = { rp: 100, gp: 100, bp: 100, ap:100, ro: 0, go: 0, bo: 0, ao:0};		// for all frames on layer		for(var f = 0; f < layer.frameCount; f++){			tl.currentFrame = f;						var frame = layer.frames[f];			var elementHidden = (frame.elements.length == 0);			var element = (emptyLayer || elementHidden) ? null : frame.elements[0];			var isTween = frame.isMotionObject();						// frame that spans multiple frames			// this is a first frame in a tween			if(frame.startFrame == f){				// frame label				if(frame.name.length){					if(frame.labelType == 'name'){						frameLabels.push('{"f":'+f+', "l":"'+frame.name+'"}');					} else if(frame.labelType == 'comment'){						frameComments.push('{"f":'+f+', "c":"'+frame.name+'"}');					}				}				// get color transform				if(!emptyLayer){					motionTween = null;					if(isTween) {						motionTween = extractMotionTween(frame.getMotionObjectXML());						motionTween = (motionTween && motionTween.length) ? motionTween : null;					}					if(!element){						currentCtx = { rp: 100, gp: 100, bp: 100, ap:100, ro: 0, go: 0, bo: 0, ao:0};					} else if(!motionTween){						// note - Flash doesn't save color percent values < 0, bug since Flash CS5, amazingly bad.						currentCtx.rp = element.colorRedPercent;						currentCtx.gp = element.colorGreenPercent;						currentCtx.bp = element.colorBluePercent;						currentCtx.ap = element.colorAlphaPercent;						currentCtx.ro = element.colorRedAmount;						currentCtx.go = element.colorGreenAmount;						currentCtx.bo = element.colorBlueAmount;						currentCtx.ao = element.colorAlphaAmount;					}				}			}						if(element){				if(element.symbolType != 'graphic') {					fl.trace("ERROR: symbol " + element.libraryItem.name.split('/').pop() + " on frame " + (f + 1) + " is not of type 'graphic'");					return;				}				var actualFrame = element.firstFrame;				var nthFrame = (f - frame.startFrame);				var nframes = element.libraryItem.timeline.frameCount;				if(element.loop == 'loop'){					actualFrame = (element.firstFrame + nthFrame) % nframes;				} else if(element.loop == 'play once'){					actualFrame = Math.min(element.firstFrame + nthFrame, nframes - 1);				}								if(isTween && motionTween){					currentCtx = motionTween[Math.min(motionTween.length - 1, nthFrame)];				}								var transPoint = element.getTransformationPoint();				currentAnim.push('{'								 + '"f":' + actualFrame + ', '								 + '"c":"' + currentCtx.rp + ',' + currentCtx.gp + ',' + currentCtx.bp + ',' + currentCtx.ap + ',' 								 + currentCtx.ro + ',' + currentCtx.go + ',' + currentCtx.bo + ',' + currentCtx.ao + '", '								 + (elementHidden ? '"h":1, ' : '')								 + (!isTween ? '' : ('"m":'+ (frame.startFrame + 1) + ', ')) // static frame, not part of tween								 + '"x":' + element.transformX + ', '								 + '"y":' + element.transformY + ', '								 + ((transPoint.x != 0 || transPoint.y != 0) ?								 	('"tx":' + transPoint.x + ', ' + '"ty":' + transPoint.y + ', ') : '')								 + '"sx":' + element.scaleX + ', '								 + '"sy":' + element.scaleY + ', '								 + '"rx":' + element.skewX + ', ' + '"ry":' + element.skewY								 + '}');			} else if(!emptyLayer && elementHidden){				currentAnim.push('{'								 + '"f":0, '								 + '"h":1, '								 + '"s":1, ' // static frame, not part of tween								 + '"x":0, '								 + '"y":0, '								 + '"sx":1, '								 + '"sy":1, '								 + '"r":0'								 + '}');			}		}		if(!emptyLayer) layerAnims.push('[' + currentAnim.join(',\n') + ']');	}			var thisItemName = tl.libraryItem.name.split('/').pop();	var output = '{"name":"' + thisItemName + '", "fps": ' + doc.frameRate + ',\n'				+ '"frameLabels":[' + frameLabels.join(',') + '],\n'				+ '"frameComments":[' + frameComments.join(',') + '],\n'				+ '"layerAnims":[' + layerAnims.join(',') + '],\n'				+ '"layerSymbols":[' + layerSymbols.join(',') + '],\n'				+ '"symbols":' + exportLibrarySymbols(path, usedSymbols, exportSymbols) + '\n'				+ '}';	// write out	FLfile.remove(path + thisItemName + '.json');	FLfile.write(path + thisItemName + '.json', output);	fl.trace(thisItemName + ".json:\n" + output);}function extractMotionTween(xmlString){	var xml = eval(xmlString);	var timeScale = xml.@TimeScale;	var numFrames = xml.@duration / 1000;	var colorProps = xml.PropertyContainer[0].PropertyContainer.(@id == 'Colors');	if(!colorProps || !colorProps.length()) return null; // no color tween		var res = [];	var keyFrames;		// advanced transform	keyFrames = colorProps.PropertyContainer.(@id == 'Advanced_ColorXform');	if(keyFrames.length()){		// prefill		for(var i = 0; i < numFrames; i++){ res[i] = { rp:100, gp:100, bp:100, ap:100, ro: 0, go: 0, bo: 0, ao: 0 } };		var rpFrames = keyFrames.Property.(@id == 'AdvClr_R_Pct');		var roFrames = keyFrames.Property.(@id == 'AdvClr_R_Offset');		var gpFrames = keyFrames.Property.(@id == 'AdvClr_G_Pct');		var goFrames = keyFrames.Property.(@id == 'AdvClr_G_Offset');		var bpFrames = keyFrames.Property.(@id == 'AdvClr_B_Pct');		var boFrames = keyFrames.Property.(@id == 'AdvClr_B_Offset');		var apFrames = keyFrames.Property.(@id == 'AdvClr_A_Pct');		var aoFrames = keyFrames.Property.(@id == 'AdvClr_A_Offset');				// interpolate		interpolateProperty(res, rpFrames, 'rp');		interpolateProperty(res, gpFrames, 'gp');		interpolateProperty(res, bpFrames, 'bp');		interpolateProperty(res, apFrames, 'ap');		interpolateProperty(res, roFrames, 'ro');		interpolateProperty(res, goFrames, 'go');		interpolateProperty(res, boFrames, 'bo');		interpolateProperty(res, aoFrames, 'ao');			}	if(res.length) return res;		//Alpha_ColorXform	keyFrames = colorProps.PropertyContainer.(@id == 'Alpha_ColorXform');	if(keyFrames.length()){		// prefill		for(var i = 0; i < numFrames; i++){ res[i] = { rp:100, gp:100, bp:100, ap:100, ro: 0, go: 0, bo: 0, ao: 0 } };				var aFrames = keyFrames.Property.(@id == 'Alpha_Amount');				// interpolate		interpolateProperty(res, aFrames, 'ap');	}	if(res.length) return res;		//Brightness_ColorXform	keyFrames = colorProps.PropertyContainer.(@id == 'Brightness_ColorXform');	if(keyFrames.length()){		// prefill		for(var i = 0; i < numFrames; i++){ res[i] = { rp:100, gp:100, bp:100, ap:100, ro: 0, go: 0, bo: 0, ao: 0 } };				var bFrames = keyFrames.Property.(@id == 'Brightness_Amount');				// interpolate		interpolateProperty(res, bFrames, function(obj, interpolatedValue){ 								obj.rp = obj.gp = obj.bp = 100 - interpolatedValue;								obj.ro = obj.go = obj.bo = Math.max(0, interpolatedValue * 255);							});	}	if(res.length) return res;		// tint	keyFrames = colorProps.PropertyContainer.(@id == 'Tint_ColorXform');	if(keyFrames.length()){		var tintColorFrames = keyFrames.Property.(@id == 'Tint_Color');		var tintAmountFrames = keyFrames.Property.(@id == 'Tint_Amount');		// fill res with color values interpolated		var nframes = tintColorFrames.Keyframe.length();		for(var i = 0; i < nframes; i++){			var val = rgba(tintColorFrames.Keyframe[i].@value);			var nextVal = (i < nframes - 1) ? rgba(tintColorFrames.Keyframe[i+1].@value) : val;						var frameTime = tintColorFrames.Keyframe[i].@timevalue / 1000;			var nextFrameTime = (i < nframes - 1) ? (tintColorFrames.Keyframe[i+1].@timevalue / 1000) : (frameTime + 1)						// interpolate/fill offset part			var spanLength = (nextFrameTime - frameTime);			for(fi = 0; fi < spanLength; fi++){				var r = fi / spanLength;							res.push({ rp:100, gp:100, bp:100, ap:100,						 ro: lerp(val.r, nextVal.r, r),						 go: lerp(val.g, nextVal.g, r),						 bo: lerp(val.b, nextVal.b, r),						 ao: 0 });			}		}		// fill tail		var lf = res[res.length - 1];		while(res.length < numFrames){			res.push({ rp:lf.rp, gp:lf.gp, bp:lf.bp, ap:lf.ap, ro:lf.ro, go:lf.go, bo:lf.bo, ao:lf.ao });		}				// interpolate color using tint amount		interpolateProperty(res, tintAmountFrames, function(obj, lv){								obj.rp = obj.gp = obj.bp = 100 - lv;								lv *= 0.01;								obj.ro *= lv;								obj.go *= lv;								obj.bo *= lv;							});	}	return res;}function interpolateProperty(res, rpFrames, prop){	var nframes = rpFrames.Keyframe.length();	var lastFrame = null;	for(var i = 0; i < nframes; i++){		var val = rpFrames.Keyframe[i].@anchor.split(',')[1];		var nextVal = (i < nframes - 1) ? rpFrames.Keyframe[i+1].@anchor.split(',')[1] : val;				var frameTime = rpFrames.Keyframe[i].@timevalue / 1000;		var nextFrameTime = (i < nframes - 1) ? (rpFrames.Keyframe[i+1].@timevalue / 1000) : (frameTime + 1)		lastFrame = rpFrames.Keyframe[i];				// interpolate/fill offset part		var spanLength = (nextFrameTime - frameTime); 		for(var n = frameTime; n < nextFrameTime; n++){			var obj = res[n];			var r = (n - frameTime) / spanLength;			var lv = lerp(val, nextVal, r);			if(typeof(prop) == 'function'){				prop(obj, lv);			} else {				obj[prop] = lv;			}		}	}	// fill tail	if(lastFrame){		var frameTime = lastFrame.@timevalue / 1000;		var val = lastFrame.@anchor.split(',')[1];		for(var n = frameTime; n < res.length; n++){			var obj = res[n];			if(typeof(prop) == 'function'){				prop(obj, lv);			} else {				obj[prop] = lv;			}		}	}}function lerp(a, b, c) { return Number(a) + (b - a) * c; }function rgba(hex) {    var bigint = parseInt(hex, 16);    var r = (bigint >> 24) & 255;    var g = (bigint >> 16) & 255;    var b = (bigint >> 8) & 255;    var a = bigint & 255;    return {r:r,g:g,b:b,a:a};}// export each frame of each graphic as a png, and dimensions/offsets as jsonfunction exportLibrarySymbols(path, symbols, exportSymbols){	var doc = fl.getDocumentDOM();	var lib = doc.library;	var tl = doc.getTimeline();	var symbolsOut = [ ];		// reset	tl.currentFrame = 0;	tl.currentLayer = 0;		// for all given symbols	for(var iname in symbols){		var item = symbols[iname];				if(item.symbolType != 'graphic') { 			fl.trace("WARNING: "+iname+" is used as a MovieClip. All symbols on timeline must be Graphic.");			continue;		}				// create export layer		tl.setSelectedLayers(0, true);		var exportLayer = tl.addNewLayer("Export", "normal", true);		doc.selectNone();		// add to stage				if(!doc.addItem({x:0, y:0}, item)) {			fl.trace("WARNING: "+iname+" is used as a MovieClip. All symbols on timeline must be Graphic.");			continue;		}				// find it		var sitem = tl.layers[0].frames[0].elements[0];		sitem.loop = 'single frame';				var output = '{"name":"'+item.name.split('/').pop()+'", "frames":\n[';				// get offset in each frame		var frameOut = [ ];		for(var frame = 0; frame < item.timeline.frameCount; frame++){			sitem.firstFrame = frame;			sitem.x = 0; sitem.y = 0;			frameOut.push('[' + sitem.left + ', ' + sitem.top + ', ' + sitem.width + ', ' + sitem.height + ']');		}				output += frameOut.join(',') + ']}';				symbolsOut.push(output);				// graphic		if(exportSymbols) item.exportToPNGSequence(path + item.name.split('/').pop() + '.png');				// delete export layer		tl.deleteLayer(exportLayer)	}		return '[' + symbolsOut.join(',') + ']';}// this function is only tested on a Mac. You may need to modify it for it to work on Winfunction pickFolder(){	// Get a location to export images to. trim the file:/// from it using join and split	var folderURI = decodeURI(fl.browseForFolderURL("Select a folder").split("file:///").join("")); 		if(!folderURI) return null; 	// split path into an array on the forward slash	var folderItems = folderURI.split("/");	 	// On the Mac we need to remove the first item in the path	var saveDir = "file:///" + folderItems.slice(1,folderItems.length).join("/") + "/";	 	// if there is a save Directory specified then process the library items	if (saveDir) {		fl.trace("Folder selected: "+saveDir);	}	return saveDir;}